
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nexusLIMS.extractors.fei_emi &#8212; NexusLIMS 1.4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-styles.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/custom.js"></script>
    <link rel="shortcut icon" href="../../../_static/nexusLIMS_bare_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
  <script src="https://code.jquery.com/jquery-1.12.4.min.js" type="text/javascript"></script>
  <script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>


<script type="text/javascript" src="https://pages.nist.gov/leaveNotice/js/jquery.leaveNotice-nist.min.js"></script>
<script>
$(document).ready(function(){
  // Mark external (non-nist.gov) A tags with class "external"
  //If the adress start with https and ends with nist.gov
  var re_nist = new RegExp('^https?:\/\/((^\/)*\.)*nist\\.gov(\/|$)');
  var re_nist_github = new RegExp('^https:\/\/github.com\/usnistgov(\/|$)');
  //Regex to find address that start with https
  var re_absolute_address = new RegExp('^((https?:)?\/\/)');
  $("a").each(function(){
    var url=$(this).attr('href');
    if(re_nist.test(url) || !re_absolute_address.test(url) || re_nist_github.test(url)){
      $(this).addClass('leave_notice_local');
    }else{
      //This a href appears to be external, so tag it
      $(this).addClass('leave_notice_external');
    }
  });
  // Add leaveNotice to external A elements
  $('a.leave_notice_external').leaveNotice();
});
</script>
<link rel="stylesheet" type="text/css" href="https://pages.nist.gov/leaveNotice/css/jquery.leaveNotice.css" />

  </head><body>

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/logo_horizontal.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>1.4.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../api.html">API Docs</a></li>
                <li><a href="https://github.com/usnistgov/NexusLIMS">Repository</a></li>
                <li><a href="https://www.nist.gov/mml/odi">NIST ODI</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site Map <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Package introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">NexusLIMS database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../record_building.html">Record building workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../taxonomy.html">NexusLIMS taxonomy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../schema_documentation.html">Schema documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customizing_cdcs.html">Tips for customizing CDCS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../session_logger_app.html">Session logging (deprecated)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/nexusLIMS.html">nexusLIMS package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/nexusLIMS.builder.html">nexusLIMS.builder package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/nexusLIMS.db.html">nexusLIMS.db package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/nexusLIMS.extractors.html">nexusLIMS.extractors package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/nexusLIMS.harvesters.html">nexusLIMS.harvesters package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/nexusLIMS.harvesters.nemo.html">nexusLIMS.harvesters.nemo package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/nexusLIMS.schemas.html">nexusLIMS.schemas package</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li class="dummy-sidebarrel">
    <a><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Previous</span>
    </a>
  </li>
  <li class="dummy-sidebarrel">
    <a><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Next &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><img src="../../../_static/nexusLIMS_bare_logo.png">
<h4><a href="../../../index.html" title="Return to documentation home">
    NexusLIMS Documentation</a></h4>
<ul class="globaltoc">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Package introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">NexusLIMS database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../record_building.html">Record building workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../taxonomy.html">NexusLIMS taxonomy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../schema_documentation.html">Schema documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customizing_cdcs.html">Tips for customizing CDCS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../session_logger_app.html">Session logging (deprecated)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API documentation</a></li>
</ul>

</ul><h4>
    <a class="no-hover">Page content</a>
</h4>


<form action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for nexusLIMS.extractors.fei_emi</h1><div class="highlight"><pre>
<span></span><span class="c1">#  NIST Public License - 2019</span>
<span class="c1">#</span>
<span class="c1">#  This software was developed by employees of the National Institute of</span>
<span class="c1">#  Standards and Technology (NIST), an agency of the Federal Government</span>
<span class="c1">#  and is being made available as a public service. Pursuant to title 17</span>
<span class="c1">#  United States Code Section 105, works of NIST employees are not subject</span>
<span class="c1">#  to copyright protection in the United States.  This software may be</span>
<span class="c1">#  subject to foreign copyright.  Permission in the United States and in</span>
<span class="c1">#  foreign countries, to the extent that NIST may hold copyright, to use,</span>
<span class="c1">#  copy, modify, create derivative works, and distribute this software and</span>
<span class="c1">#  its documentation without fee is hereby granted on a non-exclusive basis,</span>
<span class="c1">#  provided that this notice and disclaimer of warranty appears in all copies.</span>
<span class="c1">#</span>
<span class="c1">#  THE SOFTWARE IS PROVIDED &#39;AS IS&#39; WITHOUT ANY WARRANTY OF ANY KIND,</span>
<span class="c1">#  EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED</span>
<span class="c1">#  TO, ANY WARRANTY THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY</span>
<span class="c1">#  IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,</span>
<span class="c1">#  AND FREEDOM FROM INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION</span>
<span class="c1">#  WILL CONFORM TO THE SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE</span>
<span class="c1">#  ERROR FREE.  IN NO EVENT SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING,</span>
<span class="c1">#  BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES,</span>
<span class="c1">#  ARISING OUT OF, RESULTING FROM, OR IN ANY WAY CONNECTED WITH THIS SOFTWARE,</span>
<span class="c1">#  WHETHER OR NOT BASED UPON WARRANTY, CONTRACT, TORT, OR OTHERWISE, WHETHER</span>
<span class="c1">#  OR NOT INJURY WAS SUSTAINED BY PERSONS OR PROPERTY OR OTHERWISE, AND</span>
<span class="c1">#  WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT OF THE RESULTS OF,</span>
<span class="c1">#  OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parses and extract metadata from files saved by the TIA software.</span>

<span class="sd">Handles files saved by FEI&#39;s (now Thermo Fisher Scientific) TIA (Tecnai Imaging and</span>
<span class="sd">Analysis) software. This software package saves data in two types of files: ``.ser``</span>
<span class="sd">and ``.emi``. The ``.emi`` file contains metadata about the data acquisition, while</span>
<span class="sd">the (one or more) ``.ser`` files contain the actual collected data. Thus, access to</span>
<span class="sd">both is required for full metadata extraction and preview generation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span> <span class="k">as</span> <span class="n">dt</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">hyperspy.io</span> <span class="kn">import</span> <span class="n">load</span> <span class="k">as</span> <span class="n">hs_load</span>
<span class="kn">from</span> <span class="nn">hyperspy.signal</span> <span class="kn">import</span> <span class="n">BaseSignal</span>

<span class="kn">from</span> <span class="nn">nexusLIMS.instruments</span> <span class="kn">import</span> <span class="n">get_instr_from_filepath</span>
<span class="kn">from</span> <span class="nn">nexusLIMS.utils</span> <span class="kn">import</span> <span class="n">set_nested_dict_value</span><span class="p">,</span> <span class="n">sort_dict</span><span class="p">,</span> <span class="n">try_getting_dict_value</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># noinspection PyBroadException</span>
<div class="viewcode-block" id="get_ser_metadata"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.get_ser_metadata">[docs]</a><span class="k">def</span> <span class="nf">get_ser_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get metadat from .ser file.</span>

<span class="sd">    Returns metadata (as a dict) from an FEI .ser file + its associated .emi</span>
<span class="sd">    files, with some non-relevant information stripped.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename</span>
<span class="sd">        Path to FEI .ser file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        Metadata of interest which is extracted from the passed files. If</span>
<span class="sd">        files cannot be opened, at least basic metadata will be returned (</span>
<span class="sd">        creation time, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ObjectInfo present in emi; ser_header_parameters present in .ser</span>
    <span class="c1"># ObjectInfo should contain all the interesting metadata,</span>
    <span class="c1"># while ser_header_parameters is mostly technical stuff not really of</span>
    <span class="c1"># interest to anyone</span>
    <span class="n">warning</span><span class="p">,</span> <span class="n">emi_filename</span><span class="p">,</span> <span class="n">ser_error</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>

    <span class="c1"># pylint: disable=broad-exception-caught</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">emi_filename</span><span class="p">,</span> <span class="n">ser_index</span> <span class="o">=</span> <span class="n">get_emi_from_ser</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">emi_loaded</span> <span class="o">=</span> <span class="n">_load_ser</span><span class="p">(</span><span class="n">emi_filename</span><span class="p">,</span> <span class="n">ser_index</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="c1"># if emi wasn&#39;t found, specifically mention that</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;NexusLIMS could not find a corresponding .emi metadata &quot;</span>
            <span class="s2">&quot;file for this .ser file. Metadata extraction will be &quot;</span>
            <span class="s2">&quot;limited.&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
        <span class="n">emi_loaded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">emi_filename</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># otherwise, HyperSpy could not load the .emi, so give generic warning</span>
        <span class="c1"># that .emi could not be loaded for some reason:</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;The .emi metadata file associated with this &quot;</span>
            <span class="s2">&quot;.ser file could not be opened by NexusLIMS. &quot;</span>
            <span class="s2">&quot;Metadata extraction will be limited.&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
        <span class="n">emi_loaded</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">emi_loaded</span><span class="p">:</span>
        <span class="c1"># pylint: disable=broad-exception-caught</span>

        <span class="c1"># if we couldn&#39;t load the emi, lets at least open the .ser to pull</span>
        <span class="c1"># out the ser_header_info</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">hs_load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">only_valid_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The .ser file could not be opened (perhaps file is &quot;</span>
                <span class="s2">&quot;corrupted?); Metadata extraction is not possible.&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
            <span class="c1"># set s to an empty signal just so we can process some basic</span>
            <span class="c1"># metadata using same syntax as if we had read it correctly</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">ser_error</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">original_metadata</span><span class="o">.</span><span class="n">as_dictionary</span><span class="p">()</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># if we&#39;ve already encountered a warning, add that to the metadata,</span>
    <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Extractor Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">warning</span>
    <span class="c1"># otherwise check to ensure we actually have some metadata read from .emi</span>
    <span class="k">elif</span> <span class="s2">&quot;ObjectInfo&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="s2">&quot;ExperimentalConditions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">]</span>
        <span class="ow">and</span> <span class="s2">&quot;ExperimentalDescription&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;No experimental metadata was found in the &quot;</span>
            <span class="s2">&quot;corresponding .emi file for this .ser. &quot;</span>
            <span class="s2">&quot;Metadata extraction will be limited.&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Extractor Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">warning</span>

    <span class="c1"># if we successfully found the .emi file, add it to the metadata</span>
    <span class="k">if</span> <span class="n">emi_filename</span><span class="p">:</span>
        <span class="n">rel_emi_fname</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">emi_filename</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;mmfnexus_path&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">emi_filename</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;emi Filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_emi_fname</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;emi Filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Get the instrument object associated with this file</span>
    <span class="n">instr</span> <span class="o">=</span> <span class="n">get_instr_from_filepath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="c1"># if we found the instrument, then store the name as string, else None</span>
    <span class="n">instr_name</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">instr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;fname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="c1"># get the modification time:</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Creation Time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">instr</span><span class="o">.</span><span class="n">timezone</span> <span class="k">if</span> <span class="n">instr</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Instrument ID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">instr_name</span>

    <span class="c1"># we could not read the signal, so add some basic metadata and return</span>
    <span class="k">if</span> <span class="n">ser_error</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_handle_ser_error</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="n">parse_basic_info</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">instr</span><span class="p">)</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">parse_acquire_info</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">parse_experimental_conditions</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">parse_experimental_description</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="p">(</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Data Type&quot;</span><span class="p">],</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;DatasetType&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">parse_data_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># we don&#39;t need to save the filename, it&#39;s just for internal processing</span>
    <span class="k">del</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;fname&quot;</span><span class="p">]</span>

    <span class="c1"># sort the nx_meta dictionary (recursively) for nicer display</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort_dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<span class="k">def</span> <span class="nf">_handle_ser_error</span><span class="p">(</span><span class="n">metadata</span><span class="p">):</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;DatasetType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Misc&quot;</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Data Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># sort the nx_meta dictionary (recursively) for nicer display</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort_dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">])</span>
    <span class="k">del</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;fname&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">metadata</span>


<span class="k">def</span> <span class="nf">_load_ser</span><span class="p">(</span><span class="n">emi_filename</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">ser_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load an data file given the .emi filename and an index of which signal to use.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emi_filename</span>
<span class="sd">        The path to an .emi file</span>
<span class="sd">    ser_index</span>
<span class="sd">        Which .ser file to load data from, given the .emi file above</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hyperspy.signal.BaseSignal</span>
<span class="sd">        The signal loaded by HyperSpy</span>
<span class="sd">    bool</span>
<span class="sd">        Whether the emi file was successfully loaded (should be true if no Exceptions)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># approach here is for every .ser we want to examine, load the</span>
    <span class="c1"># metadata from the corresponding .emi file. If multiple .ser files</span>
    <span class="c1"># are related to this emi, HyperSpy returns a list, so we select out</span>
    <span class="c1"># the right signal from that list if that&#39;s what is returned</span>

    <span class="c1"># make sure to load with &quot;only_valid_data&quot; so data shape is correct</span>
    <span class="c1"># loading the emi with HS will try loading the .ser too, so this will</span>
    <span class="c1"># fail if there&#39;s an issue with the .ser file</span>
    <span class="n">emi_s</span> <span class="o">=</span> <span class="n">hs_load</span><span class="p">(</span><span class="n">emi_filename</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_valid_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># if there is more than one dataset, emi_s will be a list, so pick</span>
    <span class="c1"># out the matching signal from the list, which will be the &quot;index&quot;</span>
    <span class="c1"># from the filename minus 1:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emi_s</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">emi_s</span><span class="p">[</span><span class="n">ser_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># otherwise we should just have a regular signal, so make s the same</span>
    <span class="c1"># as the data loaded from the .emi</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emi_s</span><span class="p">,</span> <span class="n">BaseSignal</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">emi_s</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="kc">True</span>


<div class="viewcode-block" id="parse_basic_info"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.parse_basic_info">[docs]</a><span class="k">def</span> <span class="nf">parse_basic_info</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">instrument</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse basic metadata from file.</span>

<span class="sd">    Parse the metadata that is saved at specific places within</span>
<span class="sd">    the .emi tag structure into a consistent place in the metadata dictionary</span>
<span class="sd">    returned by :py:meth:`get_ser_metadata`. Specifically, this method handles</span>
<span class="sd">    the creation date, equipment manufacturer, and data shape/type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the dataset</span>
<span class="sd">    instrument : Instrument</span>
<span class="sd">        The instrument this file was collected on</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        The same metadata dictionary with some values added under the</span>
<span class="sd">        root-level ``nx_meta`` key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># try to set creation time to acquisition time from metadata</span>
    <span class="n">acq_time</span> <span class="o">=</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;AcquireDate&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">acq_time</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Creation Time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
                <span class="n">acq_time</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">%a</span><span class="s2"> %b </span><span class="si">%d</span><span class="s2"> %H:%M:%S %Y&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">instrument</span><span class="o">.</span><span class="n">timezone</span> <span class="k">if</span> <span class="n">instrument</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="c1"># manufacturer is at high level, so parse it now</span>
    <span class="n">manufacturer</span> <span class="o">=</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;Manufacturer&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">manufacturer</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Manufacturer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">manufacturer</span>

    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Data Dimensions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># set type to STEM Image by default (this seems to be most common)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;DatasetType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Image&quot;</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Data Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;STEM_Imaging&quot;</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="parse_experimental_conditions"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.parse_experimental_conditions">[docs]</a><span class="k">def</span> <span class="nf">parse_experimental_conditions</span><span class="p">(</span><span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse experimental conditions.</span>

<span class="sd">    Parse the metadata that is saved at specific places within</span>
<span class="sd">    the .emi tag structure into a consistent place in the metadata dictionary</span>
<span class="sd">    returned by :py:meth:`get_ser_metadata`. Specifically looks at the</span>
<span class="sd">    &quot;ExperimentalConditions&quot; node of the metadata structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        The same metadata dictionary with some values added under the</span>
<span class="sd">        root-level ``nx_meta`` key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">term_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s2">&quot;DwellTimePath&quot;</span><span class="p">,):</span> <span class="s2">&quot;Dwell Time Path (s)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;FrameTime&quot;</span><span class="p">,):</span> <span class="s2">&quot;Frame Time (s)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;CameraNamePath&quot;</span><span class="p">,):</span> <span class="s2">&quot;Camera Name Path&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;Binning&quot;</span><span class="p">,):</span> <span class="s2">&quot;Binning&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;BeamPosition&quot;</span><span class="p">,):</span> <span class="s2">&quot;Beam Position (μm)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;EnergyResolution&quot;</span><span class="p">,):</span> <span class="s2">&quot;Energy Resolution (eV)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;IntegrationTime&quot;</span><span class="p">,):</span> <span class="s2">&quot;Integration Time (s)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;NumberSpectra&quot;</span><span class="p">,):</span> <span class="s2">&quot;Number of Spectra&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;ShapingTime&quot;</span><span class="p">,):</span> <span class="s2">&quot;Shaping Time (s)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;ScanArea&quot;</span><span class="p">,):</span> <span class="s2">&quot;Scan Area&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;AcquireInfo&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">map_keys</span><span class="p">(</span><span class="n">term_mapping</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># remove units from beam position (if present)</span>
    <span class="k">if</span> <span class="s2">&quot;Beam Position (μm)&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Beam Position (μm)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span>
            <span class="s2">&quot;Beam Position (μm)&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; um&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="parse_acquire_info"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.parse_acquire_info">[docs]</a><span class="k">def</span> <span class="nf">parse_acquire_info</span><span class="p">(</span><span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse acquisition conditions.</span>

<span class="sd">    Parse the metadata that is saved at specific places within</span>
<span class="sd">    the .emi tag structure into a consistent place in the metadata dictionary</span>
<span class="sd">    returned by :py:meth:`get_ser_metadata`. Specifically looks at the</span>
<span class="sd">    &quot;AcquireInfo&quot; node of the metadata structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        The same metadata dictionary with some values added under the</span>
<span class="sd">        root-level ``nx_meta`` key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">term_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s2">&quot;AcceleratingVoltage&quot;</span><span class="p">,):</span> <span class="s2">&quot;Microscope Accelerating Voltage (V)&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;Tilt1&quot;</span><span class="p">,):</span> <span class="s2">&quot;Microscope Tilt 1&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="s2">&quot;Tilt2&quot;</span><span class="p">,):</span> <span class="s2">&quot;Microscope Tilt 2&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;ExperimentalConditions&quot;</span><span class="p">,</span> <span class="s2">&quot;MicroscopeConditions&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">map_keys</span><span class="p">(</span><span class="n">term_mapping</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">metadata</span>  <span class="c1"># noqa: RET504</span></div>


<div class="viewcode-block" id="parse_experimental_description"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.parse_experimental_description">[docs]</a><span class="k">def</span> <span class="nf">parse_experimental_description</span><span class="p">(</span><span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse experimental description.</span>

<span class="sd">    Parse the metadata that is saved at specific places within</span>
<span class="sd">    the .emi tag structure into a consistent place in the metadata dictionary</span>
<span class="sd">    returned by :py:meth:`get_ser_metadata`. Specifically looks at the</span>
<span class="sd">    &quot;ExperimentalDescription&quot; node of the metadata structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        The same metadata dictionary with some values added under the</span>
<span class="sd">        root-level ``nx_meta`` key</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The terms to extract in this section were</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># These terms were captured by looping through a selection of</span>
    <span class="c1"># representative .ser/.emi datafiles and running something like the</span>
    <span class="c1"># following</span>
    <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;ExperimentalDescription&quot;</span><span class="p">]</span>

    <span class="n">experimental_description</span> <span class="o">=</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">experimental_description</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">experimental_description</span><span class="p">,</span>
        <span class="nb">dict</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">term_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ObjectInfo&quot;</span><span class="p">][</span><span class="s2">&quot;ExperimentalDescription&quot;</span><span class="p">]:</span>
            <span class="n">term</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">split_fei_metadata_units</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;uA&quot;</span><span class="p">,</span> <span class="s2">&quot;μA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;um&quot;</span><span class="p">,</span> <span class="s2">&quot;μm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;deg&quot;</span><span class="p">,</span> <span class="s2">&quot;°&quot;</span><span class="p">)</span>
            <span class="n">term_mapping</span><span class="p">[(</span><span class="n">k</span><span class="p">,)]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">term</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">unit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="c1"># Make stage position a nested list</span>
            <span class="k">if</span> <span class="s2">&quot;Stage&quot;</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Stage &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">term_mapping</span><span class="p">[(</span><span class="n">k</span><span class="p">,)]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;Stage Position&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">term</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">unit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="c1"># Make filter settings a nested list</span>
            <span class="k">if</span> <span class="s2">&quot;Filter &quot;</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Filter &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">term_mapping</span><span class="p">[(</span><span class="n">k</span><span class="p">,)]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;Tecnai Filter&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">term</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">unit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                <span class="p">]</span>

        <span class="n">metadata</span> <span class="o">=</span> <span class="n">map_keys</span><span class="p">(</span><span class="n">term_mapping</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

        <span class="c1"># Microscope Mode often has excess spaces, so fix that if needed:</span>
        <span class="k">if</span> <span class="s2">&quot;Mode&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="get_emi_from_ser"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.get_emi_from_ser">[docs]</a><span class="k">def</span> <span class="nf">get_emi_from_ser</span><span class="p">(</span><span class="n">ser_fname</span><span class="p">:</span> <span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the accompanying `.emi` filename from an ser filename.</span>

<span class="sd">    This method assumes that the `.ser` file will be the same name as the `.emi` file,</span>
<span class="sd">    but with an underscore and a digit appended. i.e. ``file.emi`` would</span>
<span class="sd">    result in `.ser` files named ``file_1.ser``, ``file_2.ser``, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ser_fname</span>
<span class="sd">        The absolute path of an FEI TIA `.ser` data file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    emi_fname</span>
<span class="sd">        The absolute path of the accompanying `.emi` metadata file</span>
<span class="sd">    index : int</span>
<span class="sd">        The number of this .ser file (i.e. 1, 2, 3, etc.)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    FileNotFoundError</span>
<span class="sd">        If the accompanying .emi file cannot be resolved to be a file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># separate filename from extension</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">ser_fname</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">ser_fname</span><span class="o">.</span><span class="n">stem</span>
    <span class="c1"># remove everything after the last underscore and add the .emi extension</span>
    <span class="n">emi_fname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;.emi&quot;</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">emi_fname</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Could not find .emi file with expected name: </span><span class="si">{</span><span class="n">emi_fname</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">emi_fname</span><span class="p">,</span> <span class="n">index</span></div>


<div class="viewcode-block" id="split_fei_metadata_units"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.split_fei_metadata_units">[docs]</a><span class="k">def</span> <span class="nf">split_fei_metadata_units</span><span class="p">(</span><span class="n">metadata_term</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split metadata into value and units.</span>

<span class="sd">    If present, separate a metadata term into its value and units.</span>
<span class="sd">    In the FEI metadata structure, units are indicated separated by an</span>
<span class="sd">    underscore at the end of the term. i.e. ``High tension_kV`` indicates that</span>
<span class="sd">    the `High tension` metadata value has units of `kV`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata_term : str</span>
<span class="sd">        The metadata term read from the FEI tag structure</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mdata_and_unit : :obj:`tuple` of :obj:`str`</span>
<span class="sd">        A length-2 tuple with the metadata value name as the first</span>
<span class="sd">        item and the unit (if present) as the second item</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mdata_and_unit</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">metadata_term</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdata_and_unit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mdata_and_unit</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">mdata_and_unit</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># capitalize any words in metadata term that are all lowercase:</span>
    <span class="n">mdata_term</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span> <span class="k">else</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">mdata_and_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()],</span>
    <span class="p">)</span>
    <span class="c1"># replace weird &quot;Stem&quot; capitalization</span>
    <span class="n">mdata_term</span> <span class="o">=</span> <span class="n">mdata_term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Stem &quot;</span><span class="p">,</span> <span class="s2">&quot;STEM &quot;</span><span class="p">)</span>

    <span class="n">mdata_and_unit</span> <span class="o">=</span> <span class="p">(</span><span class="n">mdata_term</span><span class="p">,</span> <span class="n">mdata_and_unit</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">mdata_and_unit</span></div>


<div class="viewcode-block" id="map_keys"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.map_keys">[docs]</a><span class="k">def</span> <span class="nf">map_keys</span><span class="p">(</span><span class="n">term_mapping</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map keys into NexusLIMS metadata structure.</span>

<span class="sd">    Given a term mapping dictionary and a metadata dictionary, translate</span>
<span class="sd">    the input keys within the &quot;raw&quot; metadata into a parsed value in the</span>
<span class="sd">    &quot;nx_meta&quot; metadata structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    term_mapping : dict</span>
<span class="sd">        Dictionary where keys are tuples of strings (the input terms),</span>
<span class="sd">        and values are either a single string or a list of strings (the</span>
<span class="sd">        output terms).</span>
<span class="sd">    base : list</span>
<span class="sd">        The &#39;root&#39; path within the metadata dictionary of where to start</span>
<span class="sd">        applying the input terms</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        The same metadata dictionary with some values added under the</span>
<span class="sd">        root-level ``nx_meta`` key, as specified by ``term_mapping``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``term_mapping`` parameter should be a dictionary of the form:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        {</span>
<span class="sd">            (&#39;val1_1&#39;, &#39;val1_2&#39;) : &#39;output_val_1&#39;,</span>
<span class="sd">            (&#39;val1_1&#39;, &#39;val2_2&#39;) : &#39;output_val_2&#39;,</span>
<span class="sd">            etc.</span>
<span class="sd">        }</span>

<span class="sd">    Assuming ``base`` is ``[&#39;ObjectInfo&#39;, &#39;AcquireInfo&#39;]``, this would map</span>
<span class="sd">    the term present at ``ObjectInfo.AcquireInfo.val1_1.val1_2`` into</span>
<span class="sd">    ``nx_meta.output_val_1``, and ``ObjectInfo.AcquireInfo.val1_1.val2_2`` into</span>
<span class="sd">    ``nx_meta.output_val_2``, and so on. If one of the output terms is a list,</span>
<span class="sd">    the resulting metadata will be nested. `e.g.` ``[&#39;output_val_1&#39;,</span>
<span class="sd">    &#39;output_val_2&#39;]`` would get mapped to ``nx_meta.output_val_1.output_val_2``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">in_term</span> <span class="ow">in</span> <span class="n">term_mapping</span><span class="p">:</span>
        <span class="n">out_term</span> <span class="o">=</span> <span class="n">term_mapping</span><span class="p">[</span><span class="n">in_term</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_term</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">in_term</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_term</span><span class="p">)</span>  <span class="c1"># noqa: PLW2901</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_term</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">out_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_term</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">try_getting_dict_value</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">in_term</span><span class="p">)</span>
        <span class="c1"># only add the value to this list if we found it</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="s2">&quot;not found&quot;</span><span class="p">:</span>
            <span class="n">set_nested_dict_value</span><span class="p">(</span>
                <span class="n">metadata</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">out_term</span><span class="p">],</span>
                <span class="n">_convert_to_numeric</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="parse_data_type"><a class="viewcode-back" href="../../../api/nexusLIMS.extractors.html#nexusLIMS.extractors.fei_emi.parse_data_type">[docs]</a><span class="k">def</span> <span class="nf">parse_data_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the data type from the signal&#39;s metadata.</span>

<span class="sd">    Determine `&quot;Data Type&quot;` and `&quot;DatasetType&quot;` for the given .ser file based</span>
<span class="sd">    off of metadata and signal characteristics. This method is used to</span>
<span class="sd">    determine whether the image is TEM or STEM, Image or Diffraction,</span>
<span class="sd">    Spectrum or Spectrum Image, etc.</span>

<span class="sd">    Due to lack of appropriate metadata written by the FEI software,</span>
<span class="sd">    a heuristic of axis limits and size is used to determine whether a</span>
<span class="sd">    spectrum&#39;s data type is EELS or EDS. This may not be a perfect</span>
<span class="sd">    determination.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : :py:class:`hyperspy.signal.BaseSignal` (or subclass)</span>
<span class="sd">        The HyperSpy signal that contains the data of interest</span>
<span class="sd">    metadata : dict</span>
<span class="sd">        A metadata dictionary as returned by :py:meth:`get_ser_metadata`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_type : str</span>
<span class="sd">        The string that should be stored at metadata[&#39;nx_meta&#39;][&#39;Data Type&#39;]</span>
<span class="sd">    dataset_type : str</span>
<span class="sd">        The string that should be stored at metadata[&#39;nx_meta&#39;][&#39;DatasetType&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># default value that will be overwritten if the conditions below are met</span>
    <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Misc&quot;</span>

    <span class="c1"># instrument configuration</span>
    <span class="n">instr_conf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_set_instrument_type</span><span class="p">(</span><span class="n">instr_conf</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># images have signal dimension of two:</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">signal_dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># noqa: PLR2004</span>
        <span class="n">instr_mod</span><span class="p">,</span> <span class="n">dataset_type</span> <span class="o">=</span> <span class="n">_signal_dim_2</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># if signal dimension is 1, it&#39;s a spectrum and not an image</span>
    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">signal_dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">instr_mod</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Spectrum&quot;</span><span class="p">]</span>
        <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Spectrum&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">navigation_dimension</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">instr_mod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Imaging&quot;</span><span class="p">)</span>
            <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;SpectrumImage&quot;</span>
        <span class="c1"># do some basic axis value analysis to guess signal type since we</span>
        <span class="c1"># don&#39;t have any indication of EELS vs. EDS; assume 5 keV and above</span>
        <span class="c1"># is EDS</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">signal_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">high_value</span> <span class="o">&gt;</span> <span class="mi">5000</span><span class="p">:</span>  <span class="c1"># noqa: PLR2004</span>
            <span class="k">if</span> <span class="s2">&quot;EDS&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instr_conf</span><span class="p">:</span>
                <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EDS&quot;</span><span class="p">)</span>
        <span class="c1"># EELS spectra are usually 2048 channels</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">signal_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2048</span><span class="p">:</span>  <span class="c1"># noqa: PLR2004</span>
            <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;EELS&quot;</span><span class="p">)</span>

    <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">instr_conf</span> <span class="o">+</span> <span class="n">instr_mod</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">dataset_type</span></div>


<span class="k">def</span> <span class="nf">_set_instrument_type</span><span class="p">(</span><span class="n">instr_conf</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
    <span class="c1"># sometimes there is no metadata for follow-on signals in an .emi/.ser</span>
    <span class="c1"># bundle (i.e. .ser files after the first one)</span>
    <span class="k">if</span> <span class="s2">&quot;Mode&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s2">&quot;STEM&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
            <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;STEM&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;TEM&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
            <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;TEM&quot;</span><span class="p">)</span>
    <span class="c1"># if there is no metadata read from .emi, make determination</span>
    <span class="c1"># off of instrument (this is really a guess)</span>
    <span class="k">elif</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Instrument ID&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;STEM&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Instrument ID&quot;</span><span class="p">]:</span>
            <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;STEM&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;TEM&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># default to TEM, (since STEM is technically a sub-technique of TEM)</span>
        <span class="n">instr_conf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;TEM&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signal_dim_2</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse data type for a Signal with &quot;signal dimension&quot; of size 2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metadata</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        The instrument mode</span>
<span class="sd">    str</span>
<span class="sd">        The dataset type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># default to an image dataset type for 2 dimensional signal</span>
    <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Image&quot;</span>
    <span class="c1"># instrument modality:</span>
    <span class="n">instr_mod</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Imaging&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;Mode&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s2">&quot;Image&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
            <span class="n">instr_mod</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Imaging&quot;</span><span class="p">]</span>
            <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Image&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;Diffraction&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
            <span class="c1"># Diffraction mode is only actually diffraction in TEM mode,</span>
            <span class="c1"># In STEM, imaging happens in diffraction mode</span>
            <span class="k">if</span> <span class="s2">&quot;STEM&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
                <span class="n">instr_mod</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Imaging&quot;</span><span class="p">]</span>
                <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Image&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;TEM&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nx_meta&quot;</span><span class="p">][</span><span class="s2">&quot;Mode&quot;</span><span class="p">]:</span>
                <span class="n">instr_mod</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Diffraction&quot;</span><span class="p">]</span>
                <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;Diffraction&quot;</span>
    <span class="k">return</span> <span class="n">instr_mod</span><span class="p">,</span> <span class="n">dataset_type</span>


<span class="k">def</span> <span class="nf">_convert_to_numeric</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>

    </div>
      
  </div>
</div>
  
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2023, NIST Office of Data and Informatics.<br/>
      Last updated on Sep, 19, 2023.<br/>
    </p>
  </div>
</footer>

  </body>
</html>